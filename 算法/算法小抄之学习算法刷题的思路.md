# 学习算法刷题的思路

> 数据结构的基本存储方式就是数组和链表[^1]

各个数据结构的底层实现都是 数组或者链表, 而对于数据结构的操作规范以及维度不同, 我们得到了不同的数据结构.

关于操作规范, 这里举个例子, 队列 和栈. 队列先进先出. 是因为我们只能在数据结构的前端取数据, 以及 只能在后端插入数据.

那么, 数组与链表分别适合于哪些场景呢?

数组的特性是 拥有连续的内存块, 所以, 我们查询的速度会很快. 为什么连续的内存块会让我们的查询快呢? 因为操作系统只需要记住这个数组的头地址,然后加上 一个数据类型所需的空间 * 你给的索引, 就可以算出来 你所需要访问的地址.

但是, 我们有时候是不确定我们需要多大内存的, 而且内存是有限的. 可以说, 算法就是要解决, 在有效的资源(内存)下, 如何让计算速度更快的问题的. 所以, 当内存不够的情况发生的时候, 我们需要重新开辟一块更大的内存. 并且把原来的数据拷贝过去. 这里就会耗费大量的时间.

所以, 数组的缺点就是, 为了保证数据的索引有效, 我们需要挪动数据, 以维持有效的索引, 而挪动数据就会造成时间的增加, 也就是算法复杂度的提高.

对于链表, 我们就没有挪动数据的烦恼. 因为链表的数据本来就不是连续的, 这里我们就不需要考虑维护索引. 于是, 对于数据的增删改, 链表的速度是很快的. 然而, 有得必有失, 因为没有索引, 所以查询速度. 也就是遍历速度就没有数组快, O(n). 并且, 链表所用内存比数组多, 因为需要空间来存储指针(指向链表下一个值的地址).

所以, 对数组和链表我们总结一下, 数组查询快, 但是由于存在扩容的问题, 增加与删除的动作涉及维护下标, 所以效率不高, 另外, 由于使用的连续的内存块, 如果没有正确的预估使用的内存大小, 就会造成内存的浪费, 或者原定内存不够, 转移原有数据增加算法的时间复杂度. 链表虽然需要额外的空间来存储指针, 但是不涉及扩容缩容的问题, 所以对于增删, 不需要在搞完过后额外的挪数据, 由此节约了一定的时间. 另外对于查和建立在查基础上的改. 由于没有索引,所以时间复杂度比数组要高. 

> 算法就是对数据结构的遍历 + 访问 (增删查该) [^1]

对于访问我们讨论了数组和链表两种方式. 遍历一定程度上来讲, 和查找是类似的. 

查找是给你一个值, 你查一下, 数据结构中是否存在这个值, 而这个过程, 就涉及到了遍历. 对于数据结构中的每一个数, 我们都取一遍. 

> 遍历分为 线性遍历 (for\where) 和 非线性遍历(递归)[^1]

这里的线性遍历也就是说是有顺序的. 从前到后, 或者从后到前. 然而递归却不是.

> 学习算法要有框架思维[^1]

这里的框架思维, 指的就是解题套路. 作者建议 先刷二叉树



[^1]: labuladong的算法小抄

